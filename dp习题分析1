给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3：

输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
示例 4：

输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
示例 5：

输入：s = "mississippi" p = "mis*is*p*."
输出：false


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/regular-expression-matching

解题思路，首先这是一个有限范围内求最优解的题型，因为我们的字符串长度有限，我们在用*进行匹配的时候并不知道可以匹配对方多少位，因为我们并不知道
给定的s的字符串情况是什么，只能尽可能地去拿这做对比。这就隐含了一个贪心地意思，但凡可以被误解为贪心地大概率可以可以用dp来尝试一下
那么关于如何思考这个题呢，我们可以将匹配地过程看成一个滑动地窗口，如果相同的话，就让滑块往前走
根据题意来说*是匹配前一位，那么我们如果从左到右走，我们是只能通过i+1来判读是不是有*的出现，对比我们从右到左，略显尴尬，因为从右往左我们是
先知道有*的存在，然后根据*的位置就能获取前一位是什么。而左到右，我们后知道有没有*，相当于我们知道了，必须得回溯，那么很麻烦，不如通过有*就对比，无*就继续走的方式来
解题更好

此题我们考虑前i和前j位字符是否匹配，那么即便i，j匹配与否，i-1，j-1也得匹配，不然我们直接就return false了
  label:  所以我们设f(x,y)为前j-1个是否匹配前j-1个字符，结果为一个布尔类型    他具象化为一个二维数组  dp[x][y]    
那么f(0,0)就可以看作是s,p字符串都为空的情况，那么都是空就是true,所以我们初始化f(0,0)=true；
  int a=s.length()+1; 接着我们需要拿到字符串的长度
  int b=p.length()+1;
这里为什么会+1呢，因为我们我们要让记录f(0,0)为字符串为空的情况，寻常条件下我们都知道0位就是数组或者字符串的第一位，我们这里硬把第00位当作null位
那么整体情况都要往后推一位，相当于给x行y列硬插了一个值，其他值的索引都要+1
!这里请注意我们虽然这样做，但是依然还是把f(x,y)当为前j-1个是否匹配前j-1个字符
i-1,j-1是未知数，不管我们怎么减都是未知的就等于infinity-1还是infinity,但是我们矩阵的长度是有限的，我们模拟了两个字符串对应关系，形式是这个矩阵

把i当为s的指针，把j当成p的指针
紧接着就是我们最难的判断问题
当aaa aaa 或者aaa aa.的情况时，也就是我们的指针从右走，现在所指向的值结果是相同的或者p[j]对应的现在的值为'.'
p(y)='.'  ||p(Y)=s(x)
那么这样情况我们就让
f(x,y)=f(x-1,y-1)
就是让指针左移的意思，因为相同所以同时左移

那么假如遇到* 就复杂了很多
假设我们j来到了这一位，对应的是*，那么我们就要分几种情况
第一种  aa a*
我们直接让s的指针左移一位，这时就变成了a a* 就变成了另一种情况了，就会进入别的步骤进行分析，所以这一步没啥毛病
具体为
f(x,y)=f(x-1,y)
第二种 bc bc*
也就是这种*是没用的
 直接f(x,y)=f(x,y-1)，让p指针左移，就会变成  bc bc，那么现在的情况就会来到p(y)='.'  ||p(Y)=s(x)，于是跳出判断，进行下一步
 第三种
bb bbb*
 目的是为了消失一个b
 f(x,y)=f(x,y-2)
 之后就变成了 bb bb
 
 上述为是s(x)==p(y-1)的情况，那如果不等与怎么办
 例如这种    bb bbc*  bb bb.*   (虽然.可以匹配所有，但是不能因为这个.让整体错位了，所以要单独拎出来考虑)
 这种情况依然是 f(x,y)=f(x,y-2)



class Solution {
    public boolean isMatch(String s, String p) {
       int a=s.length()+1;
       int b=p.length()+1;
        boolean[][] dp = new boolean[a][b];
        dp[0][0]=true;
       for(int i=0;i<a;i++){
           for(int j=1;j<b;j++)   //00位已经被占用，我们得从01位开始，
           {
               if(i>0&&(p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)=='.'))
               {
                   dp[i][j]=dp[i-1][j-1];
               }
               if(p.charAt(j-1)=='*')
               {
                   if(i==0||(s.charAt(i-1)!=p.charAt(j-2)&&p.charAt(j-2)!='.'))
                   {
                       dp[i][j]=dp[i][j-2];
                   }else{
                       dp[i][j]=dp[i-1][j]||dp[i][j-1]||dp[i][j-2];
                   }
               }
           }
       }
return dp[a-1][b-1];    // 关于这个最后的返回值问题，如果到这里你不明白的话，你就需要重新自己模拟一遍dp的框架，不是让你在模拟一遍指针移动，你需要知道
//dp的思考框架，第一步我们一定要设属性，   goto lable;
(所以我们设f(x,y)为前j-1个是否匹配前j-1个字符，结果为一个布尔类型    他具象化为一个二维数组  dp[x][y] )  
我们设的就是i-1 j-1是不是匹配，所以我们返回的也就是i-1 j-1到底匹配不匹配
}
}
